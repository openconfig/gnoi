//
// Copyright 2017 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package gnoi.transceiver_firmware_install;

import "github.com/openconfig/gnoi/types/types.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

option go_package = "github.com/openconfig/gnoi/transceiver_firmware_install";

option (types.gnoi_version) = "0.1.0";

// The following definitions are used throughout this service:
// - Device: the host, such as a router, that the transceiver(s) are within.
// - Transceiver: the pluggable optic that is plugged into the Device.
//
// The service provides an interface for installation of firmware on
// transceivers in a device.
// The Client progresses through RPCs in the following order:
//   1) Transfer - Performs one of two steps:
//      a) Provide the device with the package in an inactive bank which can
//         be used for multiple transceivers.
//      b) Provide the transceiver with the package to an inactive bank.
//   2) Activate - Performs the activation of the package on the transceiver.
//      Typically this would activate a package from an inactive bank on the
//      transceiver, however, if the transceiver does not support inactive
//      banks, then this step could perform the transfer and activate together.
//   3) Verify - Verify that the package is activated on the transceiver(s).
//      This is redundant to the Activate RPC responding with ActivateOK, but
//      is useful for the Client if the RPC is interrupted while in progress
//      or if the Client is interested polling for the progress of the
//      activation.
//
service TransceiverFirmwareInstall {
  // Transfer performs a package transfer from either:
  //   1) External to device.
  //   2) Device to inactive bank of an Transceiver.
  rpc Transfer(stream TransferRequest) returns (stream TransferResponse);

  // Activate initiates the activation process on a transceiver(s).
  // Activate typically requires that the package was previously transferred
  // to the device using the Transfer RPC. However, if the transceiver does not
  // support an inactive bank, this RPC can perform the transfer and activate.
  // If the transceiver is already using the desired version or the activate is
  // already in progress for the identical version, do not re-activate the
  // package unless force_activate is set to true. Otherwise, report success so
  // this RPC is idempotent.
  // If the RPC is terminated after the RPC is initiated, the activate must
  // continue in the background for ongoing activations. For example, if there
  // is a network communication issue which disrupts the RPC, the in-progress
  // activations would continue their progress.
  rpc Activate(ActivateRequest) returns (stream ActivateResponse);

  // Verify checks the firmware related details for a transceiver(s).
  // During reboot, gRPC client returns the gRPC status code UNAVAILABLE while
  // the transceiver is unreachable, which should be retried by the client until
  // successful.
  rpc Verify(VerifyRequest) returns (VerifyResponse);

  // Delete removes the package from the device's storage.
  // Deletion for a package should not be allowed if the package was bundled
  // with the OS image or if a transfer is currently in progress.
  rpc Delete(DeleteRequest) returns (DeleteResponse);
}

message TransferRequest {
  oneof request {
    TransferToDeviceRequest transfer_to_device = 1;
    TransferToTransceiverRequest transfer_to_transceiver = 2;
  }
}

// The TransferToDeviceRequest is used by the Client to transfer the package to
// the device. The device MUST store the package in a generic location that can
// later be utilized to repeatedly transfer the package to multiple
// transceivers.
message TransferToDeviceRequest {
  oneof request {
    TransferToDeviceStartRequest transfer_start_request = 1;
    bytes transfer_content = 2;
    TransferEnd transfer_end = 3;
  }
}

message TransferToDeviceStartRequest {
  // The file name is a unique identifier for a firmware package. Typically,
  // the file name of the package (e.g., "aaa.x.y.z.tgz").
  string file_name = 1;

  // Optionally specify the package size in bytes.
  // If 1) the value is different than 0
  // and 2) the required space in the device is larger than the available space
  // and 3) the device is unable to release space for the incoming package,
  // then the device must reply with TransferError->Type->TOO_LARGE.
  uint64 package_size_bytes = 2;

  // Optionally specify the hash of the package which the device can use to
  // verify the integrity of the package. The device must reply with
  // TransferError->Type->INTEGRITY_FAIL if the hash does not
  // match the hash of the package that the device has stored.
  types.HashType hash = 3;
}

// The TransferEnd message is sent whenever the Client finishes transferring
// the package to the device. At this point the device MUST perform a general
// health check to the package. If the device fails to parse the package
// it MUST immediately reply with an TransferError->type->PARSE_FAIL. If the
// integrity check of the package fails it MUST immediately reply with an
// TransferError->type->INTEGRITY_FAIL.
message TransferEnd {

}

// The TransferToTransceiverRequest is used by the Client to transfer the
// package ONLY to an inactive bank of the transceiver.
// This would make the package available for the Activate RPC, but the package
// MUST NOT be made active as a result of this transfer.
message TransferToTransceiverRequest {
  // Absolute path to the /components/component list member in the OpenConfig
  // model corresponding to the transceiver to perform the activation on.
  // (e.g., /components/component[name=transceiver-1/2])
  types.Path transceiver = 1;

  // The file name name is a unique identifier for a firmware package. Typically,
  // the file name of the package (e.g., "aaa.x.y.z.tgz").
  string file_name = 2;

  // Optionally specify the package size in bytes.
  // If 1) the value is different than 0
  // and 2) the required space in the transceiver is larger than the available
  //        space
  // and 3) the transceiver is unable to release space for the incoming package,
  // then the device must reply with TransferError->Type->TOO_LARGE.
  // If the transceiver does not support advertising its available space, then
  // the device must return TransferError->Type->INVALID_ARGUMENT.
  uint64 package_size_bytes = 3;

  // The bank identifier of the transceiver to activate the firmware on.
  // If the transceiver only contains a single bank, then the device must reply
  // with TransferError->Type->INCOMPATIBLE.
  // If the transceiver only contains an active and standby bank, then this
  // field may be considered optional as the transfer must be made to the
  //standby bank.
  // This is a 0-based index intended to standardize the mapping of different
  // vendor specific identifers. Mapping examples of transceivers that support
  // two banks include:
  // - Active|Standby --> 0|1
  // - A|B --> 0|1
  // - 1|2 --> 0|1
  uint32 firmware_bank = 4;
}

// The TransferResponse is used by the device to inform the Client about the
// state of the Transfer RPC. At any stage of the process the device can reply
// with an Error message which MUST terminate the stream.
message TransferResponse {
  oneof response {
    TransferReady transfer_ready = 1;
    TransferProgress transfer_progress = 2;
    Validated validated = 3;
    TransferError transfer_error = 4;
  }
}

// The TransferReady message tells the Client that the device is ready to accept
// the package transfer. At this stage the device MUST have cleared enough space
// to accept the incoming package if the package size was specified.
message TransferReady {

}

// The TransferProgress message is sent by the device asynchronously during a
// file transfer. The device SHOULD not respond to each input block received
// from the client, but rather determine reasonable intervals at which to send
// the message (e.g., 5MB).
message TransferProgress {
  // The number of bytes transferred.
  uint64 bytes_received = 1;
}

// The Validated message asserts that the device was able to parse the package
// and perform integrity checks to its contents.
// This message is sent at the conclusion of a successful RPC.
message Validated {

}

// The TransferError message MUST be sent by the device to the Client whenever
// an issue occurs. The device MUST immediately close the RPC without a
// gRPC error.
message TransferError {
  enum Type {
    // An unspecified error. Must use the detail value to describe the issue.
    UNSPECIFIED = 0;
    // The newly transferred package is not compatible with the device platform.
    // The detail field MUST contain the detailed error message.
    INCOMPATIBLE = 1;
    // The package being transferred is larger than the available size the
    // client provisioned. This error may be returned if the device does not
    // have enough space for the new package and the existing packages.
    TOO_LARGE = 2;
    // Used whenever the system is unable to parse the newly transferred
    // package, like reading the version or the integrity checksums.
    PARSE_FAIL = 3;
    // The transferred package fails integrity check.
    INTEGRITY_FAIL = 4;
    // Another Transfer RPC to this device is already in progress with a
    // different firmware version. However, if the in progress transfer is for
    // the identical firmware version, then this error should not be returned
    // and the Transfer RPC should return success.
    TRANSFER_IN_PROGRESS = 5;
    // The transfer request provided an invalid argument. When this error is
    // returned, the device must provide more details in the detail field.
    INVALID_ARGUMENT = 6;
  }
  Type type = 1;
  string detail = 2;
}

message ActivateRequest {
  repeated ActivateSingleRequest activate_requests = 1;
}

message ActivateSingleRequest {
  // Absolute path to the /components/component list member in the OpenConfig
  // model corresponding to the transceiver to perform the activation on.
  // (e.g., /components/component[name=transceiver-1/2])
  types.Path transceiver = 1;

  oneof activate_from {
    ActivateFromDeviceRequest activate_from_device = 2;
    ActivateFromTransceiverBankRequest activate_from_transceiver_bank = 3;
  }

  // If true, the device MUST activate the package even if the transceiver is
  // already running the same package.
  bool force_activate = 4;
}

message ActivateFromDeviceRequest {
  // The file name is a unique identifier for a firmware package. Typically,
  // the file name of the package (e.g., "aaa.x.y.z.tgz").
  string file_name = 1;

  // Optionally specify the package size in bytes.
  // If 1) the value is different than 0
  // and 2) the required space in the transceiver is larger than the available
  //        space
  // and 3) the transceiver is unable to release space for the incoming package,
  // then the device must reply with TransferError->Type->TOO_LARGE.
  uint64 package_size_bytes = 2;
}

message ActivateFromTransceiverBankRequest {
  // The bank identifier of the transceiver to activate the firmware from.
  // This would be used if the firmware package is already pre-loaded on the
  // transceiver in an inactive bank.
  // If the transceiver only contains a single bank, then the device must reply
  // with ActivateError->Type->INCOMPATIBLE.
  // If the specified bank is empty, then the device must reply with
  // ActivateError->Type->EMPTY_FIRMWARE_BANK.
  // This is a 0-based index intended to standardize the mapping of different
  // vendor specific identifers. Mapping examples of transceivers that support
  // two banks include:
  // - Active|Standby --> 0|1
  // - A|B --> 0|1
  // - 1|2 --> 0|1
  uint32 firmware_bank = 4;
}

message ActivateResponse {
  repeated ActivateSingleResponse activate_responses = 1;
}

message ActivateSingleResponse {
  // Absolute path to the /components/component list member in the OpenConfig
  // model corresponding to the transceiver to perform the activations on.
  // (e.g., /components/component[name=transceiver-1/2])
  types.Path transceiver = 1;

  oneof response {
    ActivateReady activate_ready = 2;
    TransferProgress transfer_progress = 3;
    ActivateProgress activate_progress = 4;
    ActivateOK activate_ok = 5;
    ActivateError activate_error = 6;
  }
}

// The ActivateReady message tells the Client that the device is ready to accept
// the package activation. At this stage the device MUST have cleared enough
// space to accept the incoming package if the package size was specified.
message ActivateReady {

}

// The ActivateProgress message signals the Client about the progress of the
// transceiver activation process.
message ActivateProgress {
  // The percentage complete of the activate process.
  uint32 percentage_activated = 1;
}

// ActivateOK is sent when the package is successfully activated on the
// transceiver.
// If the transceiver is already running the requested version in
// ActivateRequest, then it replies with ActivateOK.
message ActivateOK {

}

// The ActivateError message MUST be sent by the device to the Client whenever
// an issue occurs. If there are other in progress activations from the same
// RPC, then no further messages for this transceiver activation would be sent.
// However, if there are not other in progress activations from the same RPC
// then the device MUST immediately close the RPC without a gRPC error.
message ActivateError {
  enum Type {
    // An unspecified error. Must use the detail value to describe the issue.
    UNSPECIFIED = 0;
    // There is no package with the version requested for activation. This is
    // also used for an empty version string.
    NON_EXISTENT_VERSION = 1;
    // The newly transferred package is not compatible with the transceiver.
    // The detail field MUST contain the detailed error message.
    INCOMPATIBLE = 2;
    // The package being transferred is larger than the available size the
    // client provisioned. This error may be returned if the transceiver does
    // not have enough space for the new package and the existing packages.
    TOO_LARGE = 3;
    // Used whenever the system is unable to parse the newly transferred
    // package, like reading the version or the integrity checksums.
    PARSE_FAIL = 4;
    // The transferred package fails integrity check.
    INTEGRITY_FAIL = 5;
    // Another Activate RPC to this device is already in progress with a
    // different firmware version. However, if the in progress activate is for
    // the identical firmware version, then this error should not be returned
    // and the Activate RPC should return success.
    ACTIVATE_IN_PROGRESS = 6;
    // A switchover happened during the Activate RPC.
    UNEXPECTED_SWITCHOVER = 7;
    // Used when a specified bank is empty and does not contain a package.
    EMPTY_FIRMWARE_BANK = 8;
  }
  Type type = 1;
  string detail = 2;
}

message VerifyRequest {
  repeated VerifySingleRequest verify_requests = 1;
}

message VerifySingleRequest {
  // Absolute path to the /components/component list member in the OpenConfig
  // model corresponding to the transceiver to verify.
  // (e.g., /components/component[name=transceiver-1/2])
  types.Path transceiver = 1;
}

message VerifyResponse {
  repeated VerifySingleResponse verify_responses = 1;
}

message VerifySingleResponse {
  // Absolute path to the /components/component list member in the OpenConfig
  // model corresponding to the transceiver to verify.
  // (e.g., /components/component[name=transceiver-1/2])
  types.Path transceiver = 1;

  // The version currently running.
  string running_version = 2;

  // The version that is being attempted to be activated.
  string new_version = 3;

  // The firmware package that is contained within each bank on the transceiver.
  repeated FirmwareBank bank = 4;

  // True if the new_version would result in a traffic disruption.
  bool new_version_service_impacting = 5;

  // The current state of the latest activate process.
  ActivateStatus activate_status = 6;

  // The current in-progress step of the activation.
  string step = 7;

  // The percentage complete of the current in-progress step.
  uint32 step_percent_complete = 8;

  // The percentage complete of the latest activate process.
  uint32 total_percent_complete = 9;

  // The time when the latest activation was initiated.
  google.protobuf.Timestamp start_time = 10;

  // The time when the latest activation was completed.
  google.protobuf.Timestamp stop_time = 11;

  // The time elapsed since the latest activation was initiated.
  google.protobuf.Duration duration = 12;

  // The failure message if the latest activation failed.
  string failure_message = 13;
}

message FirmwareBank {
  // The bank identifier of the transceiver (e.g., "A" or "B").
  string bank = 1;

  // The version of the firmware package in the bank.
  string version = 2;
}

enum ActivateStatus {
  // An unknown status.
  ACTIVATE_STATUS_UNKNOWN = 0;
  // The package is being transferred to the transceiver.
  ACTIVATE_STATUS_TRANSFER_IN_PROGRESS = 1;
  // The package is being activated on the transceiver.
  ACTIVATE_STATUS_ACTIVATE_IN_PROGRESS = 2;
  // The activation was successfully completed on the transceiver.
  ACTIVATE_STATUS_COMPLETED = 3;
  // The activation failed on the transceiver.
  ACTIVATE_STATUS_FAILED = 4;
}

message DeleteRequest {
  // The file name name is a unique identifier for a firmware package. Typically,
  // the file name of the package (e.g., "aaa.x.y.z.tgz").
  string file_name = 1;
}

message DeleteResponse {

}
