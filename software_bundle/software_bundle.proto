syntax = "proto3";

package gnoi.software_bundle;

import "github.com/openconfig/gnoi/types/types.proto";

option go_package = "github.com/openconfig/gnoi/software_bundle";

option (types.gnoi_version) = "0.1.0";

// SoftwareBundle is a service for managing software bundles on the system.
// A "software bundle" is a collection of files (e.g. RPMs, squashfs)
// which are installed to modify the behaviour of the processes on the
// system.
// Only one RPC (List, Activate, Install, Deactivate, Remove)
// may be in progress at any given time
service SoftwareBundle {

  // Shows the current state of the software bundles on the system.
  rpc List(ListRequest) returns (ListResponse);

  // Activate reloads any processes on the system for
  // which software bundles have been installed but which have not yet been
  // reloaded with those software bundles.
  // Please note that this may kill the connection if the process
  // hosting the gRPC server reloads, so the server is not guaranteed
  // to return a response here.
  rpc Activate(ActivateRequest) returns (ActivateResponse);

  // Transfer transfers a new software bundle file and stores it
  // on persistent storage on disk.
  rpc Transfer(stream TransferRequest) returns (TransferResponse);

  // Install installs a new software bundle on the system.
  // The new software bundle may be transferred as part of the RPC.
  //
  // Expected workflows are shown in mermaid sequence diagrams in README.md.
  //
  // Note that all installations will install the software bundle, but that
  // software bundle will not be applied until the affected services
  // are reloaded.
  // To reload services after installing software bundles, issue an
  // Activate RPC after finishing the Install RPC.
  rpc Install(stream InstallRequest) returns (InstallResponse);

  // Deactivate uninstalls an software bundle.
  // It returns an error if the requested software bundle is not installed.
  // The software bundle file will still remain on disk. To remove it, issue
  // a Remove RPC.
  rpc Deactivate(DeactivateRequest) returns (DeactivateResponse);

  // Remove cleans up the software bundle from disk.
  // It returns an error if the requested software bundle is not uninstalled.
  rpc Remove(RemoveRequest) returns (RemoveResponse);
}

message ListRequest{
}
message ListResponse{
  enum InstallStatus {
    // UNSPECIFIED should be treated as an error.
    UNSPECIFIED = 0;
    INSTALLED = 1;
    NOT_INSTALLED = 2;

    // This software bundle was force-installed - checks regarding
    // signature or dependencies may have been ignored
    FORCE_INSTALLED = 3;
  }
  message SoftwareBundle {
    // name of the software bundle
    string software_bundle_name = 1;
    // arbitrarily-formatted version string for the software bundle.
    // This version would be extracted from the software bundle itself,
    // as a way for vendors to identify extensions.
    // (since the software_bundle_name is provided by the client).
    string version = 2;
    string description = 3;
    InstallStatus install_status = 4;

    // If persistent is true, then the system will ensure
    // that this software bundle is applied on startup
    // if system reboots (e.g. via the System.Reboot RPC).
    // If persistent is false then the system will not
    // re-apply this software bundle after startup.
    bool persistent = 5;

    // bool indicating if this software bundle has a valid signature
    bool signature_valid = 6;

    // available is true if the software bundle file is still available
    // on the system.
    // the software bundle may be installed but no longer available
    // if the software bundle file has been removed.
    bool available = 7;

    // any errors attached to this software bundle
    string errors = 8;

    // affected_processes is a list of the processes which can be affected
    // by this software bundle.
    // This list may be incomplete if the system cannot determine all of the
    // processes that could be affected.
    repeated string affected_processes = 9;

    // processes_pending_restart is a list of the processes which are waiting
    // be restarted to apply the software bundle.
    // This list will be cleared after an Activate RPC executes
    // and restarts the affected processes.
    repeated string processes_pending_restart = 10;
  }
  repeated SoftwareBundle software_bundles = 1;
}

message ActivateRequest{
  string software_bundle_name = 1;
}
message ActivateResponse{
}

message DeactivateRequest{
  // name of the software bundle to be uninstalled
  string software_bundle_name = 1;

  // a boolean indicating whether we should force uninstalling
  // this software bundle.
  // if set to true, then ignore conflicts and dependencies
  // when uninstalling.
  bool force = 2;
}

message DeactivateResponse{
}

message RemoveRequest{
  // name of the software bundle to be removed
  string software_bundle_name = 1;
}
message RemoveResponse{
}

message InstallResponse{
}

// InstallRequest is a request for installing an software bundle onto a system.
// The software bundle is applied to the running configuration.
message InstallRequest{
  // software_bundle_name is the name of the software bundle to install.
  // This is required because Install can be called
  // for an software bundle which is already present on the system
  string software_bundle_name = 1;

  // If persistent is true, then the system will ensure
  // that this software bundle is applied on startup
  // if system reboots (e.g. via the System.Reboot RPC).
  // If persistent is false then the system will not
  // re-apply this software bundle after startup.
  bool persistent = 3;

  // if this is true, then the system will force installation of the
  // software bundle. This can cause checks
  // (e.g. regarding missing dependencies) to be ignored.
  bool force = 4;

  enum TrustSource {
    // UNSPECIFIED should be treated as an error.
    UNSPECIFIED = 0;
    // IGNORE = ignore signature verification. Allows any software bundle
    // (even one with missing/invalid signature) to be installed
    IGNORE = 1;
    // MANUFACTURER = trust only software bundles which have been signed
    // by the device manufacturer to be installed.
    MANUFACTURER = 2;
  }
  oneof signature_verification {
    TrustSource source = 5;
    // trust software bundles which are valid according to
    // the SSL profile specified by the ssl_profile_id field.
    // Creating and populating SSL profiles is out of the scope of this
    // service and should be done through some other means (e.g. gNSI Certz).
    string ssl_profile_id = 6;
  }
}

message TransferRequest{
  oneof request {
    // name of the software bundle
    // This should be unique.
    // If a software bundle already exists with this name, the
    // RPC should fail with an ALREADY_EXISTS error code.
    string software_bundle_name = 1;
    // raw byte contents to be streamed into the software bundle file.
    bytes contents = 2;
    // hash of the file.
    types.HashType hash = 3;
  }
}

message TransferResponse {
}